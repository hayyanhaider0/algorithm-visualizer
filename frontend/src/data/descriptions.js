const descriptions = {
  linkedList: {
    paragraphs: [
      "A linked list is a fundamental data structure in computer science, which consists of a sequence of nodes. Each node in a linked list contains two parts:",
      "1. Data Field: This holds the actual data or value stored in the node.",
      "2. Pointer (or Reference) Field: This contains the memory address or reference to the next node in the sequence.",
      "The linked list begins with a special node called the head, which serves as the entry point. The last node, often referred to as the tail, has a pointer that is either null or points to a sentinel value, indicating the end of the list.",
      "Unlike arrays, which store elements in contiguous memory locations, linked lists provide a more flexible, dynamic memory structure. Nodes can be inserted or removed without shifting elements in memory, making it particularly efficient for certain operations, such as adding or deleting elements from the beginning or middle of the list.",
      "Types of Linked Lists:",
      "Singly Linked List: In a singly linked list, each node contains a pointer to the next node, and traversal is done in one directionâ€”from the head to the tail.",
      "Doubly Linked List: Each node has two pointers: one pointing to the next node and another pointing to the previous node, allowing bi-directional traversal.",
      "Circular Linked List: The last node in the list points back to the head, creating a circular structure where traversal can potentially loop indefinitely.",
    ],
  },
  stack: {
    paragraphs: [
      "A stack is a fundamental data structure in computer science that follows the Last In, First Out (LIFO) principle. The most recently added element is the first one to be removed. It operates like a stack of plates, where you add plates to the top and remove the topmost plate first.",
      "Core Operations:",
      "1. Push: This operation adds an element to the top of the stack.",
      "2. Pop: This operation removes and returns the topmost element from the stack.",
      "3. Peek: This operation allows you to view the topmost element without removing it.",
      "4. IsEmpty: This operation checks whether the stack is empty.",
      "A stack can be implemented using arrays or linked lists, where each element is added or removed from the top. The top of the stack is either the end of the array or the head of the linked list, depending on the implementation.",
      "Types of Stacks:",
      "1. Array-Based Stack: The stack is implemented using an array, and the size of the stack is managed by resizing the array as needed.",
      "2. Linked List-Based Stack: Each element in the stack is represented by a node in a linked list, where the top of the stack is the head of the list.",
      "Stacks are used in many computer science problems, such as expression evaluation, recursion, and managing function calls in a program.",
    ],
  },
  queue: {
    paragraphs: [
      "A queue is another fundamental data structure in computer science that follows the First In, First Out (FIFO) principle. The first element added to the queue is the first one to be removed. It operates like a line at a coffee shop, where the first person in line is the first to be served.",
      "Core Operations:",
      "1. Enqueue: This operation adds an element to the end of the queue.",
      "2. Dequeue: This operation removes and returns the element from the front of the queue.",
      "3. Peek: This operation allows you to view the element at the front of the queue without removing it.",
      "4. IsEmpty: This operation checks whether the queue is empty.",
      "Queues are typically implemented using arrays or linked lists, where the front and back of the queue are either the beginning or end of the array/list, respectively.",
      "Types of Queues:",
      "1. Array-Based Queue: The queue is implemented using an array, and the size of the queue is managed by resizing the array when needed.",
      "2. Linked List-Based Queue: Each element in the queue is represented by a node in a linked list, where the front of the queue is the head and the back is the tail of the list.",
      "Queues are widely used in many real-world applications, such as scheduling tasks, handling requests in web servers, and managing processes in operating systems.",
    ],
  },
  bst: {
    paragraphs: [
      "A Binary Search Tree (BST) is a type of binary tree where each node has at most two children, referred to as the left and right children. The key property of a BST is that for any given node, the values of all the nodes in its left subtree are less than its own value, and the values of all the nodes in its right subtree are greater.",
      "Core Operations:",
      "1. Insert: This operation adds a new node with a specified value into the BST while maintaining the BST property.",
      "2. Search: This operation finds a node with a specified value in the BST, starting from the root and following the left or right child based on the comparison of values.",
      "3. Delete: This operation removes a node from the BST and rearranges the tree to preserve the BST property.",
      "4. Traversal: This operation visits all the nodes in the tree, commonly performed in one of three ways:",
      "   - In-Order: Visit left child, node, right child (produces sorted order).",
      "   - Pre-Order: Visit node, left child, right child.",
      "   - Post-Order: Visit left child, right child, node.",
      "5. Find Minimum/Maximum: These operations return the node with the minimum or maximum value in the BST, respectively, typically by traversing the leftmost or rightmost child of the tree.",
      "6. IsEmpty: This operation checks whether the BST is empty (i.e., it has no nodes).",
      "A BST is a dynamic data structure, meaning that it can grow and shrink as needed, and it allows for efficient searching, insertion, and deletion operations, with time complexity of O(log n) on average (for balanced trees).",
      "Types of Binary Search Trees:",
      "1. Self-Balancing BST: A variant of BST that automatically keeps the tree balanced, such as AVL trees and Red-Black trees, to ensure that the operations have O(log n) time complexity in the worst case.",
      "2. Unbalanced BST: A BST where no specific mechanism is used to maintain balance, which can lead to inefficient operations if the tree becomes skewed.",
      "BSTs are widely used in applications such as database indexing, sorting algorithms, and maintaining ordered data.",
    ],
  },
  heap: {
    paragraphs: [
      "A Binary Heap is a specialized binary tree that satisfies the heap property. Each node in a binary heap has at most two children, and the values in the tree adhere to a specific order depending on the type of heap:",
      "- Min-Heap: The value of each parent node is less than or equal to the values of its children.",
      "- Max-Heap: The value of each parent node is greater than or equal to the values of its children.",
      "Core Operations:",
      "1. Insert: This operation adds a new element to the heap while maintaining the heap property by performing an operation called 'heapify-up' or 'bubble-up'.",
      "2. Extract (Remove Root): This operation removes the root element (minimum in a min-heap, maximum in a max-heap) and restores the heap property by performing 'heapify-down'.",
      "3. Peek: This operation retrieves the root element without removing it, providing the smallest (min-heap) or largest (max-heap) value.",
      "4. Build Heap: This operation constructs a heap from an unsorted array by repeatedly applying heapify operations.",
      "5. Heapify: A fundamental operation that restores the heap property for a subtree, typically performed during insertion, deletion, or heap construction.",
      "6. IsEmpty: This operation checks whether the heap contains any elements.",
      "Binary heaps are complete binary trees, meaning that all levels of the tree are fully filled except possibly the last, which is filled from left to right.",
      "Binary heaps are commonly used to implement priority queues and are efficient for heap sort, with insertion and extraction operations having a time complexity of O(log n).",
      "Types of Binary Heaps:",
      "1. Min-Heap: Used when the smallest element is prioritized, as in Dijkstra's shortest path algorithm.",
      "2. Max-Heap: Used when the largest element is prioritized, as in certain scheduling algorithms.",
      "Binary heaps provide a compact and efficient way to manage priority-based data while maintaining predictable performance.",
    ],
  },
};

export default descriptions;
